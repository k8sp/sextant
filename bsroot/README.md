# `bsroot`

The *bootstrapper* Docker image contains services including dnsmasq,
cloud-config-server, and Docker registry.  The general idea about
*bsroot* is that we put most data files and configuration files for
these services in a directory on the host, and this directory will be
mounted into the bootstrapper container as `/bsroot`.

## Directory Structure

- `/bsroot/dnsmasq.conf`: The dnsmasq config file.  It is supposed to
  be generated by the `github.com/k8sp/auto-install/bootstrapper`
  program from translating a `cluster-desc.yml` file that describes
  the Kubernetes
  cluster. [TODO(yi): We need a link here to explain more about `cluster-desc.yml`.]

- `/bsroot/registry.yml`: The Docker registry config file.  It is
  supposed to be generated by the
  `github.com/k8sp/auto-install/bootstrapper` program.

- `/bsroot/registry/`: The directory mounted to bootstrapper container
  as registry volume.  It is created by the Docker registry service
  running inside the bootstrapper container.  This directory is
  mentioned in `/bsroot/registry.yml`.

## Build and Run

The real bootstrapper image will contain several services, just in the
current early stage I write a Dockerfile as an example that describes
only one service, the Docker registry.  To build a Docker image from
this Dockerfile:

```
docker build -t registry -f registry.Dockerfile .
```

To run the bootstrapper as a Docker container named `registry`:
```
docker run -d --privileged -p 5000:5000 --name registry -v $(pwd)/bsroot:/bsroot registry
```

Then we should be able to push an image into it:
```
docker tag hello-world bootstrapper:5000/hello
docker push bootstrapper:5000/hello
```

### TLS with Docker Registry

To make the Docker registry service accessible from whereever
computers, we need to set up TLS.  The basic idea include

1. Create a self-signed CA key/certificate pair.  Then we create a
   certificate for bootstrapper server using the self-signed CA.  Here
   we assume that the bootstrapper server can be accessed using the
   hostname `bootstrapper`.

   For more detials about the creation of certificates, please run
   `bsroot/gen-ca-and-bootstrapper-certs.bash`.  This script creates

   1. bsroot/ca.key
   1. bsroot/ca.crt
   1. bsroot/bootstrapper.key
   1. bsroot/bootstrapper.crt

1. Let Docker registry service use the bootstrapper certificate.

   This is done by mounting `bsroot/` to the boostrapper container,
   say as `/bsroot/`, and letting the Docker registry service loading
   `/bsroot/bootstrapper.{crt,key}`.  For more details, please refer
   to `registry.Dockerfile`.

1. Then we install the self-signed CA certificate to every node in the
   cluster.  This makes every node can access our Docker registry
   service running on the bootstrapper server.

   - If nodes run CoreOS, steps to adding a CA certificate are listed
     [here](https://coreos.com/os/docs/latest/adding-certificate-authorities.html).

   - For Ubuntu, steps include:
   
      ```
      sudo cp ca.crt /usr/share/ca-certificates/
      sudo dpkg-reconfigure ca-certificates
      sudo update-ca-certificates
      ```

## VM-based Testing

To develop and test above settings, I created
`vm-cluster/Vagrantfile`, which when used with `vagrant up`, creates a
cluster of two VMs: `bootstrapper` and `node`.  It makes sure that

1. Each VM has two NIC: `eth0` for talking to the host, and `eth1`
connected to the same virtual local network `vboxnet6`.

1. Both VMs have  Docker installed during provisioning.

1. Both VMs have a line added to `/etc/hosts`, so they can access the
   bootstrapper VM using the `bootstrapper` hostname.

1. `~/work` on the host is made VirtualBox shared folder and mounted
   to both VMs as `/work`.


### Build and Test Bootstrapper

Get the source code to host and creates TLS assets for bootstrapper:

```
host $ mkdir ~/work
host $ export GOPATH=$HOME/work
host $ go get github.com/k8sp/auto-install
host $ cd $GOPATH/src/github.com/k8sp/auto-install/bsroot/bsroot
host $ ./gen-ca-and-bootstrapper-certs.bash
```

The last command generates `ca.{crt,key}` and `bootstrapper.{crt,key}`.

The we bring up VMs on the host:

```
host $ cd $GOPATH/src/github.com/k8sp/auto-install/bsroot/vm-cluster
host $ vagrant up
```

Node that this mounts `~/work` on the host to `/work` of both VMs.

Build and run the bootstrapper Docker image on the bootstrapper VM:

```
host $ vagrant ssh bootstrapper
bootstrapper $ cd /work/src/github.com/k8sp/auto-install/bsroot
bootstrapper $ docker build -t bootstrapper -f registry.Dockerfile .
bootstrapper $ docker run -d --privileged -p 5000:5000 --name registry -v $(pwd)/bsroot:/bsroot registry
```

To test the Docker registry service, log into the `node` VM, retrieve
a toy image from Dockerhub and push it into the docker service running
on the `bootstrapper` VM:

```
host $ vagrant ssh node
node $ docker pull hello-world
node $ docker tag hello-world bootstrapper:5000/hello
node $ docker push bootstrapper:5000/hello
```

If somethings goes wrong with `docker push`, try run the bootstrapper
container on the bootstrapper VM using `docker run --rm -it` instead
of `docker run -d`.  This allows you to see outputs from the Docker
registry service running in container on the terminal.


## Troubleshooting

1. If `docker push` retries as following

   ```
   bootstrapper$ docker push localhost:5000/hello
   The push refers to a repository [localhost:5000/hello]
   a02596fdd012: Retrying in 5 seconds
   ```

   it is very likely that the Docker container doesn't have write
   permission to `/bsroot/registry`.  A simple solution is to manually
   create it and grants everyone to access it:

   ```
   bootstrapper$ mkdir /bsroot/registry
   bootstrapper$ chmod a+rwx /bsroot/registry
   ```

1. If `docker run -d ... registry` fails with no output, please replace `-d` by `--rm -it`:

   ```
   docker run --rm -it --privileged -p 5000:5000 --name registry -v $(pwd)/bsroot:/bsroot registry
   ```

   This would allow `docker run` to copy the output from `registry` to the terminal.
